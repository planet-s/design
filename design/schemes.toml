[SPC-schemes]
partof = "REQ-1-schemes"
text = '''
Schemes are the primary communication mechanism between system programs
in redox. They facilitates communication between:
- the kernel and drivers, such as the `irq` scheme
- drivers and low level interfaces, such as `ethernetd` using the `network`
  scheme (which is created directly from the driver)
- VERIFY: low level interfaces and higher level interfaces layers, such as the
  `ipd` scheme building on the `ethernet` scheme, and `tcp` scheme building on
  the `ipd` scheme.
- VERIFY: userspace programs and system level interfaces, such as the orbital
  window manager's scheme.

Most schemes should be in user space, however a few must be implemented
in kernel space ([[SPC-schemes-kernel]]) and are used both internally in the
kernel and as part of the kernel ABI.


### Example Userspace Schemes:
```
Name 	  | Description
--------  | ----------------------------------------------------------------------
redoxfs:  | Provides the standard userspace file system
orbital:  | the Desktop is rendered using only a scheme
ethernet: | Scheme from Userspace driver for raw access to the ethernet device
ip:       | IP addressing and communication scheme, builds on `ethernet:`
udp:      | UDP protocol scheme, builds on `ip:`
tcp:      | TCP protocol scheme, builds on `ip:`
```

[1]: https://github.com/redox-os/syscall
'''

[SPC-schemes-api]
text = '''
The API provided to the developer shall follow the below guide.

In order to add a scheme to redox, a developer can either:
1. open the scheme from the root scheme and then treat it as a 
  `std::fs::File` (**VERIFY** `File` implements `Scheme`)
```
let fd = syscall::open(
    ":network", 
    syscall::O_RDWR | syscall::O_CREAT | syscall::O_NONBLOCK)
    .expect( "e1000d: failed to create network scheme")
let socket = unsafe { File::from_raw_fd(socket_fd) };
```
2. implement the `redox_syscall::Scheme` trait from [redox_syscall][1]
   on a custom struct and use a `socket_fd` for scheduling.

Option #2 has the benefit that it gives you complete control over how
the scheme handles every request. It can operate like a file, socket or
something else entirely. It can handle creating or deleting files, directories,
etc. It does not have to follow "normal" file system rules.

For instance, the window manager orbital uses a scheme in order to render the
GUI. TODO: explain at a high level how orbital works and why you couldn't do
the same thing using unix files/sockets.

The full documentation for schemes can be found in the the
[`redox_syscall::scheme` crate][1]

[1]: https://github.com/redox-os/syscall
'''

[SPC-schemes-kernel]
text = '''
### Kernel Space Schemes
```
Name 	| Description
------- | ----------------------------------------------------------------------
: 	    | Root scheme - allows the creation of userspace schemes 	
debug: 	| Provides access to serial console
event: 	| Allows reading of `Event`s which are registered using fevent
env: 	| Access and modify environmental variables
initfs:	| Readonly filesystem used for initializing the system
irq: 	| Allows userspace handling of IRQs
null: 	| Scheme that will discard all writes, and read no bytes
pipe: 	| Used internally by the kernel to implement pipe
sys: 	| System information, such as the context list and scheme list
zero: 	| Scheme that will discard all writes, and always fill read buffers with zero
```
'''

[SPC-schemes-kernel-url]
text = ''' 
Url's shall be the data structure which can be opened to schemes in the kernel.
From the user perspective a url is just a C-like null-terminating string of the
form `"scheme:path/to/reference"`. Under the hood (in the kernel) they are
represented as one of the following:
- `Url<'a>`: The simplest one, just a struct containing two fat pointers,
  representing the scheme and the reference respectively. Similar to
  `std::Path::Path`
- `OwnedUrl`: This is a struct containing two Strings (that is, growable,
  heap-allocated UTF-8 string), being the scheme and the reference
  respectively. Similar to `std::path::PathBuf`.
- `CowUrl<'a>`: This is a Copy-on-Write (CoW) URL, which, when mutated, gets
  cloned to heap in order to have efficient conditional allocation of the URL.
'''

# TODO: break down each kernel scheme that has a complex design into it's own
# specification (ex: SPC-schemes-kernel-irq)
# Ones that need to be broken down: event, env, irq, sys
